%---------------------------------------------------------------------------%
% Copyright 2015 Remko Duursma, Jeff Powell                                 %
%                                                                           %
% This file is part of HIERmanual                                           %
%                                                                           %
%     HIERmanual is free software: you can redistribute it and/or modify    %
%     it under the terms of the GNU General Public License as published by  %
%     the Free Software Foundation, either version 3 of the License, or     %
%     (at your option) any later version.                                   %
%                                                                           % 
%     HIERmanual is distributed in the hope that it will be useful,         %
%     but WITHOUT ANY WARRANTY; without even the implied warranty of        %
%     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         %
%     GNU General Public License for more details.                          %
%                                                                           %
%     You should have received a copy of the GNU General Public License     %
%     along with HIERmanual.  If not, see <http://www.gnu.org/licenses/>.   %
%---------------------------------------------------------------------------%

```{r child="exercise_colorcodingexplained.Rnw", eval=TRUE}
```


### Titanic

For this section, read the data described in Section~\ref{sec:titanic} (p.~\pageref{sec:titanic}). *Note*: the data are TAB-delimited, use `read.table` as shown on p.~\pageref{sec:titanic}.

```{r }
# Note that this file is tab-delimited.
titanic <- read.table("titanic.txt", header=TRUE)
```

\begin{enumerate}
\item \easy Convert the 'Name' (passenger name) variable to a 'character' variable, and store it in the dataframe. See Section~\ref{sec:textgrep} (p.~\pageref{sec:textgrep}).
```{r }
titanic$Name <- as.character(titanic$Name)
```

\item \easy How many observations of 'Age' are missing from the dataframe? See examples in Section~\ref{sec:workingmissing} (p.~\pageref{sec:workingmissing}).
```{r }
# Look at summary:
summary(titanic$Age)

# Or count the number of missing values directly.
sum(is.na(titanic$Age))
```

\item \easy Make a new variable called 'Status', based on the 'Survived' variable already in the dataset. For passengers that did not survive, Status should be 'dead', for those who did, Status should be 'alive'. Make sure this new variable is a factor. See the example with the `ifelse` function in Section~\ref{sec:workingfactors}.
```{r }
# ifelse may return a factor, but to be sure we also use factor().
titanic$Status <- factor(ifelse(titanic$Survived==0,"dead","alive"))
```

\item \easy Count the number of passengers in each class (1st, 2nd, 3rd). *Hint:* use `table` as shown in Section~\ref{sec:workingfactors} (p.~\pageref{sec:workingfactors}).
```{r }
# The easiest way to count number of observations for each level of a factor is table()
table(titanic$PClass)
```

\item \intermed Using `grep`, find the six passengers with the last name 'Fortune'. Make this subset into a new dataframe. Did they all survive? *Hint:* to do this, make sure you recall how to use one vector to index a dataframe (see Section~\ref{sec:subsetdataframes}). Also, the `all` function might be useful here (see Section~\ref{sec:workinglogic}, p.~\pageref{sec:workinglogic}).
```{r }
# Solution with 'grep' (which returns an vector of integer numbers)
fortunepass <- titanic[grep("Fortune",titanic$Name),]

# Solution with 'grepl' (which returns a vector of TRUE/FALSE)
fortunepass <- subset(titanic, grepl("Fortune",titanic$Name))

# Did they *all* survive?
# all(fortunepass$Status == "alive") 
# it seems an extra step would be needed here
# fortunepass$Status[which(fortunepass$Survived == 1)] <- "alive"
# fortunepass$Status[which(fortunepass$Survived == 0)] <- "passed on"
# Alternatively...
all(fortunepass$Survived == 1)
```

\item \intermed As in *2.*, for what proportion of the passengers is the age unknown? Was this proportion higher for 3rd class than 1st and 2nd? *Hint:* First make a subset of the dataframe where age is missing (see Section~\ref{sec:naindataframe} on p.~\pageref{sec:naindataframe}), and then use `table`, as well as `nrow`.
```{r tidy=TRUE}
# Solution 1
# First subset the data to extract only the ones with missing Age.
# Then, count the number of observations by PClass
titanic_missage <- subset(titanic, is.na(Age))
table(titanic_missage$PClass)

# Finally, divide by the total number of rows to get
# the proportions:
table(titanic_missage$PClass) / nrow(titanic_missage)

# Solution 2:
# Take subsets where passengers are in a certain class,
# and have missing ages. Then count them.
subs1 <- subset(titanic, PClass == "1st" & is.na(Age))
subs2 <- subset(titanic, PClass == "2nd" & is.na(Age))
subs3 <- subset(titanic, PClass == "3rd" & is.na(Age))
nrow(subs1)
nrow(subs2)
nrow(subs3)

# Now divide by total number of passengers where age was missing 
# to calculate how these individuals are divided among classes:
totNAage <- nrow(subset(titanic, is.na(Age)))
nrow(subs1)/totNAage
nrow(subs2)/totNAage
nrow(subs3)/totNAage

# Solution 3:
# You can also use this shorter notation, which calculates the proportion 
# of individuals within each class for which age is not known 
# (as for solution 1):
with(subset(titanic, PClass=="1st"),
      sum(is.na(Age)) / length(Age))
with(subset(titanic, PClass=="2nd"),
      sum(is.na(Age)) / length(Age))
with(subset(titanic, PClass=="3rd"),
      sum(is.na(Age)) / length(Age))

```

\end{enumerate}


### Hydro dam

Use the hydro dam data as described in Section~\ref{sec:hydrodata}.

\begin{enumerate}
\item \easy Start by reading in the data. Change the first variable to a `Date` 
class (see Section~\ref{sec:readingdates}, p.~\pageref{sec:readingdates}). 
```{r }
hydro <- read.csv("hydro.csv")

# Note that the format of Date was D/M/Y.
library(lubridate)
hydro$Date <- as.Date(dmy(hydro$Date))
```


\item \intermed Are the successive measurements in the dataset always exactly one week apart? *Hint:* use `diff`).
```{r }
# diff() gives us the sequential differences, we can then list the unique values
# of these differences.
unique(diff(hydro$Date))
```

\item \intermed Assume that a dangerously low level of the dam is 235 $Gwh$. How many weeks was the dam level equal to or lower than this value?
```{r }
# Because the answer to the previous question was yes, 
# we can just count the number of observations where storage was < 235, like so:
sum(hydro$storage < 235)
```


\item \hard For question *2.*, how many times did `storage` decrease below 235 (regardless of how long it remained below 235)? *Hint:* use `diff` and `subset`).
```{r }
# SOLUTION 1
# Take a subset of the data where storage < 235
hydrolow <- subset(hydro, storage < 235)

# Look at time difference between successive dates
diff(hydrolow$Date)

# whenever this time difference is larger than 7,
# the level has dipped below 235 again
# (plus one, because the hydrolow dataset starts below 235)
sum(diff(hydrolow$Date) > 7) + 1

# SOLUTION 2
# Add variable that is 0 when storage < 235, 
# 1 otherwise:
hydro$storageBinary <- ifelse(hydro$storage< 235,0,1)

# Now, diff gives -1 when storage dipped below 235:
diff(hydro$storageBinary)

# How many times did it dip below 235?
difs <- diff(hydro$storageBinary)
sum(difs == -1)
```

\end{enumerate}


### HFE tree measurements

Use the data for the HFE irrigation x fertilisation experiment (see Section~\ref{sec:ifdata}, p.~\pageref{sec:ifdata}).

\begin{enumerate}
\item \easy Read the data and look at various summaries of the dataset. Use `summary`, `str` and `describe` (the latter is in the `Hmisc` package).
```{r eval=FALSE}
hfeif <- read.csv("HFEIFplotmeans.csv")
summary(hfeif)
str(hfeif)

library(Hmisc)
describe(hfeif)
```
```{r echo=FALSE}
hfeif <- read.csv("HFEIFplotmeans.csv")
```


\item \easy From these summaries, find out how many missing values there are for `height` and `diameter`. Also count the number of missing values as shown in Section~\ref{sec:workingmissing} (p.~\pageref{sec:workingmissing}).
```{r }
# is.na() gives a vector of TRUE/FALSE, which we can sum because TRUE is coded as 1,
# FALSE coded as 0.
sum(is.na(hfeif$height))
sum(is.na(hfeif$diameter))
```

\item \easy Inspect the levels of the treatment (`treat`), with the `levels` function. Also count the number of levels with the `nlevels` function. Now assign new levels to the factor, replacing the abbreviations with a more informative label. Follow the example in Section~\ref{sec:changelevels} (p.~\pageref{sec:changelevels}).

```{r }
# Inspect levels
levels(hfeif$treat)

# Count levels
nlevels(hfeif$treat)

# Replace levels
levels(hfeif$treat) <- c("Control","Fertilized","Irrigated","Liquid fertilizer")
```

\item \easy Using `table`, count the number of observations by `treat`, to check if the dataset is balanced. Be aware that `table` simply counts the number of rows, regardless of missing values. Now take a subset of the dataset where `height` is not missing, and check the number of observations again.

```{r }
# Count by factor levels
table(hfeif$treat)

# Take subset of non-missing data and try again
hfeif_nona <- subset(hfeif, !is.na(height))
table(hfeif_nona$treat)
```


\item \intermed For which dates do missing values occur in `height` in this dataset? *Hint:* use a combination of `is.na` and `unique`.
```{r }
# First make it a Date class:
library(lubridate)
hfeif$Date <- as.Date(mdy(hfeif$Date))

# Then find unique Dates where height was NA:
unique(hfeif$Date[is.na(hfeif$height)])

# Or, alternatively:
unique(hfeif[is.na(hfeif$height), "Date"])
```



\end{enumerate}

### Flux data

In this exercise, you will practice useful skills with the flux tower dataset. See Section~\ref{sec:fluxdata} (p.~\pageref{sec:fluxdata}) for a description of the dataset.

\begin{enumerate}
\item \easy Read the dataframe. Rename the first column to 'DateTime' (recall Section~\ref{sec:colrownames} on p. \pageref{sec:colrownames}).
```{r }
flux <- read.csv("fluxtower.csv")

# Rename the first column to 'DateTime'.
names(flux)[1] <- "DateTime"
```


\item \easy Convert DateTime to a `POSIXct` class. Beware of the formatting (recall Section~\ref{sec:datetime} on p.~\pageref{sec:datetime}).
```{r }
library(lubridate)

# Note the format was in D/M/Y H:M.
flux$DateTime <- dmy_hm(flux$DateTime)
```


\item \intermed Did the above action produce any missing values? Were these already missing in the original dataset? 
```{r }
# is.na returns a vector of TRUE/FALSE, any() will be TRUE if at least one of the
# supplied values is TRUE.
any(is.na(flux$DateTime))

# And now repeat on original data.
fluxorig <- read.csv("fluxtower.csv")
any(is.na(fluxorig$TIMESTAMP))
```

\item \easy Add a variable to the dataset called 'Quality'. This variable should be 'bad' when the variable 'ustar' is less than 0.15, and 'good' otherwise. Recall the example in Section~\ref{sec:workingfactors} (p.~\pageref{sec:workingfactors}).
```{r }
flux$Quality <- as.factor(ifelse(flux$ustar < 0.15, "bad","good"))
```


\item \easy Add a 'month' column to the dataset, as well as 'year'. 
```{r }
# Abbreviated month : see ?month for more options
flux$month <- month(flux$DateTime, label=TRUE)

# Year
flux$year <- year(flux$Date)
```


\item \intermed Look at the 'Rain' column. There are some problems; re-read the data or find another way to display `NA` whenever the data have an invalid value. *Hint:* look at the argument `na.strings` in `read.table`.
```{r }
# str() shows us that rain is not a numeric variable as one might expect:
str(flux$Rain)

# Now, let's fix this : both values 'NA' and '#DIV/0! should be missing values.

# Solution 1: re-read the data.
flux2 <- read.csv("fluxtower.csv", na.strings=c("NA","#DIV/0!"))

# Solution 2: set bad values to NA
flux$Rain[flux$Rain == "#DIV/0!"] <- NA
```

\end{enumerate}


### Alphabet Aerobics 3

In this exercise you will practice a bit more working with text, using the lyrics of the song 'Alphabet Aerobics' by Blackalicious. The lyrics are provided as a text file, which we can most conveniently read into a vector with `readLines`, like this,
\begin{verbatim}
lyric <- readLines("alphabet.txt")
\end{verbatim}

\begin{enumerate}
\item \easy Read the text file into a character vector like above. Count the number of characters in each line (*Hint* : use `nchar`).
```{r }
lyric <- readLines("alphabet.txt")
nchar(lyric)
```

\item \intermed Extract the first character of each line (recall examples in Section~\ref{sec:workingwithtext} on p.~\pageref{sec:workingwithtext}), and store it in a vector. Now sort this vector alphabetically and compare it to the unsorted vector. Are they the same? (*Hint* : use the `==` operator to compare the two vectors). How many are the same, that is, how many of the first letters are actually in alphabetical order already?
```{r }
# Extract first character of each line
lyric1 <- substr(lyric,1,1)

# Sort and compare
sort(lyric1) == lyric1

# And find if they are all the same
all(sort(lyric1) == lyric1)

# Count how many lines were already alphabetical
sum(sort(lyric1) == lyric1)
```

\item \hard Find the most frequent word used in the lyrics. To do this, first paste all lyrics together into one string, then split the string into words, remove commas, then count the words. You will need to use a new function that we will see again in Section~\ref{sec:lapply}. *Hint* : use a combination of `paste`, `strsplit`, `gsub`, `table` and `sort`.

```{r }
# Paste together all lyrics
lyr_all <- paste(lyric, collapse=" ")

# Remove commas
lyr_all <- gsub(",","",lyr_all)

# Split by space
lyr_words <- strsplit(lyr_all, " ")

# Sort frequencies in descending order and show only first few words
head(sort(table(lyr_words), decreasing=TRUE))
```
\end{enumerate}

### DNA Aerobics

DNA sequences can also be represented using text strings. In this exercise, you will make an artificial DNA sequence. 

\begin{enumerate}
\item \hard Make a random DNA sequence, consisting of a 100 random selections of the letters `C`,`A`,`G`,`T`, and paste the result together into one character string (*Hint* : use `sample` as in Section~\ref{sec:randomnumbers}, p.~\pageref{sec:randomnumbers} with replacement, and use `paste` as shown in Section~\ref{sec:workingwithtext}, p.~\pageref{sec:workingwithtext}). Write it in one line of R code.

```{r }
paste(sample(c("C","A","G","T"), 100, replace=TRUE), collapse="")
```


\end{enumerate}
